[
  
  {
    "Name": "initializeModel",
    "Group": "user",
    "Description": "Initializes a VisionEval model including initializing the file which keeps track of the model run state (ModelState.Rda), initializing a log file, initializing the datastore which stores all model data, parses the model run script to identify modules and the packages they are in by order of execution, checks whether all identified packages are installed and indentified modules exist within those packages, checks whether identified input files exist and comply with specifications, and loads all inputs into datastore.",
    "Arguments": 
    [
      {
        "Name": "ParamDir",
        "Description": "A string identifying the relative or absolute path to the directory where the model parameter and geography definition files are located. The default value is 'defs'."
      },
      {
        "Name": "RunParamFile",
        "Description": "RunParamFile A string identifying the name of a JSON-formatted text file that contains parameters needed to identify and manage the model run. The default value is 'run_parameters.json'."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of a text file in comma-separated values format that contains the geographic specifications for the model. The default value is 'geo.csv'."
      },
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of a JSON-formatted text file that contains global model parameters that are important to a model and may be shared by several modules."
      },
      {
        "Name": "LoadDatastore",
        "Description": "A logical identifying whether an existing datastore should be loaded."
      },
      {
        "Name": "DatastoreName",
        "Description": "A string identifying the full path name of a datastore to load or NULL if an existing datastore in the working directory is to be loaded."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A string identifying whether if an existing datastore in the working directory should be saved rather than removed."
      }
    ],
    "Return": "None. The function prints to the log file messages which identify whether or not there are errors in initialization. It also prints a success message if initialization has been successful.",
    "Calls":
    [ 
      "initModelStateFile",
      "initLog",
      "writeLog",
      "loadDatastore",
      "getModelState",
      "initDatastore",
      "readGeography",
      "initDatastoreGeography",
      "loadModelParameters",
      "parseModelScript",
      "checkModulesExist",
      "getModuleSpecs",
      "checkModuleSpecs",
      "simDataTransactions",
      "processModuleInputs",
      "inputsToDatastore"
    ]
  },
  
  {
    "Name": "runModule",
    "Group": "user",
    "Description": "Runs a module for a specified year.",
    "Arguments": 
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of a module."
      },
      {
        "Name": "PackageName",
        "Description": "A string identifying the name of the package the module is a part of."
      },
      {
        "Name": "RunFor",
        "Description": "A string identifying whether to run the module for all years 'AllYears', only the base year 'BaseYear', or for all years except the base year 'NotBaseYear'."
      },
      {
        "Name": "RunYear",
        "Description": "A string identifying the run year (e.g. '2010'). The default value is the value of the object Year in the global namespace."
      }
    ],
    "Return": "None. The function writes results to the specified locations in the datastore and prints a message to the console when the module is being run.",
    "Calls":
    [ 
      "getModelState",
      "writeLog",
      "processModuleSpecs",
      "readFromTable",
      "getFromDatastore",
      "setInDatastore"
    ]
  },
  
  {
    "Name": "initModelStateFile",
    "Group": "control",
    "Description": "Creates the model state list and loads model run parameters recorded in the 'parameters.json' file into the model state list. It also saves the model state list in a file (ModelState.Rda).",
    "Arguments": 
    [
      {
        "Name": "Dir",
        "Description": "A string identifying the name of the directory where the global parameters, deflator, and default units files are located. The default value is defs."
      },
      {
        "Name": "ParamFile",
        "Description": "A string identifying the name of the global parameters file. The default value is parameters.json."
      },
      {
        "Name": "DeflatorFile",
        "Description": "A string identifying the name of the file which contains deflator values by year (e.g. consumer price index). The default value is deflators.csv."
      },
      {
        "Name": "UnitsFile",
        "Description": "A string identifying the name of the file which contains default units for complex data types (e.g. currency, distance, speed, etc.). The default value is units.csv."
      }
    ],
    "Return": "TRUE if the model state list is created and file is saved. It creates the model state list and loads parameters recorded in the 'run_parameters.json' file into the model state lists and saves a model state file.",
    "Calls": 
    [ 
    ]
  },
  
  {
    "Name": "setModelState",
    "Group": "control",
    "Description": "Updates the list that keeps track of the model state with list of components to update and resaves in the model state file.",
    "Arguments": 
    [
      {
        "Name": "ChangeState_ls",
        "Description": "A named list of components to change in ModelState_ls."
      },
      {
        "Name": "FileName",
        "Description": "A string identifying the name of the file that contains the ModelState_ls list. The default name is 'ModelState.Rda'."
      }
    ],
    "Return": "TRUE if the model state list and file are changed.",
    "Calls":
    [ 
    ]
  },
  
   {
    "Name": "getModelState",
    "Group": "control",
    "Description": "Reads components of theModelState_ls list that keeps track of the model state.",
    "Arguments": 
    [
      {
        "Name": "Names_",
        "Description": "A string vector of the components to extract from the ModelState_ls list."
      },
      {
        "Name": "FileName",
        "Description": "A string that is the file name of the model state file. The default value is ModelState.Rda."
      }
    ],
    "Return": "A list containing the specified components from the ModelState_ls list.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "readModelState",
    "Group": "control",
    "Description": "Reads components of the file that saves a copy of the model state.",
    "Arguments": 
    [
      {
        "Name": "Names_",
        "Description": "A string vector of the components to extract from the file which stores the ModelState_ls list."
      },
      {
        "Name": "FileName",
        "Description": "A string vector with the full path name of the model state file."
      }
    ],
    "Return": "A list containing the specified components from the model state file.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getYears",
    "Group": "user",
    "Description": "Reads the Years component from the the ModelState_ls list.",
    "Arguments": 
    [
    ],
    "Return": "A character vector of the model run years.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "getUnits",
    "Group": "control",
    "Description": "Retrieves the default model units for a vector of complex data types.",
    "Arguments":
    [
      {
        "Name": "Type_",
        "Description": "A string identifying the complex data type(s)."
      }
    ],
    "Return": "A string string vector identifying the complex data type(s) or NA if any of the type(s) are not defined.",
    "Calls":
    [
      "getModelState"
    ]
  },
  
  {
    "Name": "initLog",
    "Group": "control",
    "Description": "Creates a log (text file) that stores messages generated during a model run.",
    "Arguments": 
    [
      {
        "Name": "Suffix",
        "Description": "A character string appended to the file name for the log file. For example, if the suffix is 'CreateHouseholds', the log file is named 'Log_CreateHouseholds.txt'. The default value is NULL in which case the suffix is the date and time."
      }
    ],
    "Return": "TRUE if the log is created successfully. It creates a log file in the working directory and identifies the name of the log file in the model state file.",
    "Calls":
    [ 
      "setModelState"
    ]
  },
  
  {
    "Name": "writeLog",
    "Group": "control",
    "Description": "Writes a message to the run log.",
    "Arguments": 
    [
      {
        "Name": "Msg",
        "Description": "A character string."
      },
      {
        "Name": "Print",
        "Description": "If True Msg will be printed in additon to being added to log."
      }
    ],
    "Return": "TRUE if the message is written to the log successfully. It appends the time and the message text to the run log.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "loadDatastore",
    "Group": "control",
    "Description": "Copies a saved datastore as the working datastore attributes the global list with related geographic information. This function enables scenario variants to be built from a constant set of starting conditions.",
    "Arguments": 
    [
      {
        "Name": "FileToLoad",
        "Description": "A string identifying the full path name to the saved datastore. Path name can either be relative to the working directory or absolute."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the geography definition file (see 'readGeography' function) that is consistent with the saved datastore. The geography definition file must be located in the 'defs' directory."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A logical identifying whether an existing datastore will be saved. It is renamed by appending the system time to the name. The default value is TRUE."
      }
    ],
    "Return": "TRUE if the datastore is loaded. It copies the saved datastore to working directory as 'datastore.h5'. If a 'datastore.h5' file already exists, it first renames that file as 'archive-datastore.h5'. The function updates information in the model state file regarding the model geography and the contents of the loaded datastore. If the stored file does not exist an error is thrown.",
    "Calls":
    [ 
      "getModelState",
      "setModelState",
      "listDatastore",
      "writeLog"
    ]
  },

  {
    "Name": "readGeography",
    "Group": "control",
    "Description": "Manages the reading and error checking of geographic specifications for the model.",
    "Arguments": 
    [
      {
        "Name": "Dir",
        "Description": "A string identifying the path to the geographic specifications file. Note: don't include the final separator in the path name 'e.g. not defs/'."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the geographic specifications file. This is a csv-formatted text file which contains columns named 'Azone', 'Bzone', 'Czone', and 'Marea'. The 'Azone' column must have zone names in all rows. The 'Bzone' and 'Czone' columns can be unspecified (NA in all rows) or may have have unique names in every row. The 'Marea' column (referring to metropolitan areas) identifies etropolitan areas corresponding to the most detailed level of specified geography (or 'None' no metropolitan area occupies any portion of the zone."
      }
    ],
    "Return": "The value TRUE is returned if the function is successful at reading the file and the specifications are consistent. It stops if there are any errors in the specifications. All of the identified errors are written to the run log. A data frame containing the file entries is added to the model state file as Geo_df'.",
    "Calls":
    [ 
      "checkGeography",
      "writeLog",
      "setModelState"
    ]
  },
 
  {
    "Name": "checkGeography",
    "Group": "control",
    "Description": "Reads the file containing geographic specifications for the model and checks the file entries to determine whether they are internally consistent. This function is called by the readGeography function.",
    "Arguments": 
    [
      {
        "Name": "Directory",
        "Description": "A string identifying the path to the geographic specifications file."
      },
      {
        "Name": "Filename",
        "Description": "A string identifying the name of the geographic specifications file."
      }
    ],
    "Return": "A list having two components. The first component, 'Messages', contains a string vector of error messages. If it has a length of 0 if there are no error messages. The second component, 'Update', is a list of components to update in the model state file. The components of this list include: Geo, a data frame that contains the geographic specifications; BzoneSpecified, a logical identifying whether Bzones are specified; and CzoneSpecified, a logical identifying whether Czones are specified.",
    "Calls":
    [ 
      "writeLog"
    ]
  },
  
  {
    "Name": "initDatastoreGeography",
    "Group": "control",
    "Description": "Initializes tables and writes datasets to the datastore which describe geographic relationships of the model.",
    "Arguments": 
    [
    ],
    "Return": "The function returns TRUE if the geographic tables and datasets are sucessfully written to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "initTable",
      "initDataset",
      "writeToTable",
      "writeLog"
    ]
  },
  
  {
    "Name": "loadModelParameters",
    "Group": "control",
    "Description": "Reads the 'model_parameters.json' file and stores the contents in the 'Global/Model' group of the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of the parameter file. The default value is 'model_parameters.json'."
      }
    ],
    "Return": "TRUE if the model parameters file exists and its values are sucessfully written to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "writeLog",
      "initTable",
      "writeToTable"
    ]
  },
  
  {
    "Name": "parseModelScript",
    "Group": "control",
    "Description": "Reads and parses the model script to identify the sequence of module calls and the associated call arguments.",
    "Arguments": 
    [
      {
        "Name": "FilePath",
        "Description": "A string identifying the relative or absolute path to the model run script is located."
      },
      {
        "Name": "TestMode",
        "Description": "A logical identifying whether the function is to run in test mode. When in test mode the function returns the parsed script but does not change the model state or write results to the log."
      }
    ],
    "Return": "None. A data frame containing information on the calls to 'runModule' in the order of the calls is added to the ModelState_ls list. Each row represents a module call in order. The columns identify the 'ModuleName', the 'PackageName', and the 'RunFor' value.",
    "Calls":
    [ 
      "writeLog",
      "setModelState"
    ]
  },
  
  {
    "Name": "checkModulesExist",
    "Group": "control",
    "Description": "Checks whether all required module packages are installed and whether listed modules are present in the packages.",
    "Arguments": 
    [
      {
        "Name": "ModuleCalls_df",
        "Description": "A listing of modules called in the 'run_model.R' script as created by the 'parseModelScript' function."
      }
    ],
    "Return": "TRUE if all packages and modules are present and FALSE if not.",
    "Calls":
    [ 
      "writeLog"
    ]
  },
  
  {
    "Name": "getModuleSpecs",
    "Group": "control",
    "Description": "Retrieves the specifications list for a module and returns the specifications list.",
    "Arguments": 
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module."
      },
      {
        "Name": "PackageName",
        "Description": "A string identifying the name of the package that the module is in."
      }
    ],
    "Return": "A specifications list that is the same as the specifications list defined for the module in the package.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "checkModuleSpecs",
    "Group": "control",
    "Description": "Checks all module specifications for completeness and for proper values.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the module specifications as produced by the 'processModuleSpecs' function."
      },
      {
        "Name": "ModuleName",
        "Description": "A string that identifies the name of the module (used to identify the module in any error messages.)"
      }
    ],
    "Return": "A vector containing messages identifying any errors that are found.",
    "Calls":
    [ 
      "checkSpec"
    ]
  },
  
  {
    "Name": "processModuleSpecs",
    "Group": "control",
    "Description": "Processes a specifications list and expands items that have multiple NAME listings into multiple items.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A specifications list."
      }
    ],
    "Return": "A standard specifications list with expansion of the multiple item specifications.",
    "Calls":
    [ 
      "expandSpec"
    ]
  },
  
  {
    "Name": "simDataTransactions",
    "Group": "control",
    "Description": "Loads all module specifications in order (by run year) and creates a simulated listing of the data which is in the datastore and the requests of data from the datastore and checks whether tables will be present to put datasets in and that datasets will be present that data is to be retrieved from.",
    "Arguments": 
    [
      {
        "Name": "ModuleCalls_df",
        "Description": "A data frame of module calls as produced by the 'parseModelScript' function."
      }
    ],
    "Return": "None. The function has the side effect of writing messages to the log and stops program execution if there are any errors.",
    "Calls":
    [ 
      "getModelState",
      "getYears",
      "readModelState",
      "checkTableExistence",
      "checkDataset",
      "checkSpecConsistency",
      "processModuleSpecs",
      "getDatasetAttr",
      "writeLog"
    ]
  },
  
  {
    "Name": "checkDataset",
    "Group": "control",
    "Description": "Checks whether a dataset exists in the datastore and returns a TRUE or FALSE value with an attribute of the full path to where the dataset should be located in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset name."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the table the dataset is a part of."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the ModelState_ls list."
      }
    ],
    "Return": "A logical identifying whether the dataset is in the datastore. It has an attribute that is a string of the full path to where the dataset should be in the datastore.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getDatasetAttr",
    "Group": "control",
    "Description": "Retrieves the attributes for a dataset in the datastore",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset name."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the table the dataset is a part of."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the model state file."
      }
    ],
    "Return": "A named list of the dataset attributes.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "checkTableExistence",
    "Group": "control",
    "Description": "Checks whether a table is present in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Table",
        "Description": "A string identifying the table."
      },
      {
        "Name": "Group",
        "Description": "A string or numeric representation of the group the table is a part of."
      },
      {
        "Name": "DstoreListing_df",
        "Description": "A dataframe which lists the contents of the datastore as contained in the model state file."
      }
    ],
    "Return": "A logical identifying whether a table is present in the datastore.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkSpecConsistency",
    "Group": "control",
    "Description": "Checks whether the specifications for a dataset are consistent with the data attributes in the datastore",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list of data specifications consistent with a module Get or Set specifications."
      },
      {
        "Name": "DstoreAttr_",
        "Description": "A named list where the components are the attributes of a dataset."
      }
    ],
    "Return": "A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkMatchType",
    "Group": "control",
    "Description": "Checks whether the data type of a data vector is consistent with specifications.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A data vector."
      },
      {
        "Name": "Type",
        "Description": "A string identifying the specified data type."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      }
    ],
    "Return": "A list having 2 components, Errors and Warnings. If no error or warning is identified, both components will contain a zero-length character string. If either an error or warning is identified, the relevant component will contain a character string that identifies the data field and the type mismatch.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkMatchConditions",
    "Group": "control",
    "Description": "Checks whether a data vector contains any elements that match a set of conditions.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data of type integer, double, character, or logical."
      },
      {
        "Name": "Conditions_",
        "Description": "A character vector of valid R comparison expressions or an empty vector if there are no conditions."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      },
      {
        "Name": "ConditionType",
        "Description": "ConditionType A string having a value of either PROHIBIT or UNLIKELY, the two data specifications which use conditions."
      }
    ],
    "Return": "A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkIsElementOf",
    "Group": "control",
    "Description": "Checks whether a data vector contains any elements that are not in an allowed set of values.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data of type integer, double, character, or logical."
      },
      {
        "Name": "SetElements_",
        "Description": "A vector of allowed values."
      },
      {
        "Name": "DataName",
        "Description": "A string identifying the field name of the data being compared (used for composing message identifying non-compliant fields)."
      }
    ],
    "Return": "A character vector of messages which identify the data field and the condition that is not met. A zero-length vector is returned if none of the conditions are met.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "checkDataConsistency",
    "Group": "control",
    "Description": "Checks whether data to be written to a dataset is consistent with the dataset attributes.",
    "Arguments": 
    [
      {
        "Name": "DatasetName",
        "Description": "A string identifying the dataset that is being checked."
      },
      {
        "Name": "Data_",
        "Description": "A vector of values that may be of type integer, double, character, or logical."
      },
      {
        "Name": "DstoreAttr_",
        "Description": "A named list where the components are the attributes of a dataset."
      }
    ],
    "Return": "A list containing two components, Errors and Warnings. If no inconsistencies are found, both components will have zero-length character vectors. If there are one or more inconsistencies, then these components will hold vectors of error and warning messages. Mismatch between UNITS will produce a warning message. All other inconsistencies will produce error messages.",
    "Calls":
    [ 
      "checkMatchType",
      "checkMatchConditions",
      "checkIsElementOf"
    ]
  },
  
  {
    "Name": "listDatastore",
    "Group": "datastore",
    "Description": "Lists the contents of a datastore.",
    "Arguments": 
    [
    ],
    "Return": "TRUE if the listing is successfully read from the datastore and written to the model state file.",
    "Calls":
    [ 
      "getModelState",
      "setModelState"
    ]
  },
  
  {
    "Name": "initDatastore",
    "Group": "datastore",
    "Description": "Creates datastore with starting structure.",
    "Arguments": 
    [
    ],
    "Return": "TRUE if datastore initialization is successful. Calls the listDatastore function which adds a listing of the datastore contents to the model state file.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore"
    ]
  },
  
  {
    "Name": "initTable",
    "Group": "datastore",
    "Description": "Initializes a table in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Table",
        "Description": "A string identifying the name of the table to initialize."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the group the table is to be created in."
      },
      {
        "Name": "Length",
        "Description": "A number identifying the table length."
      }
    ],
    "Return": "The value TRUE is returned if the function is successful at creating the table. In addition, the listDatastore function is run to update the inventory in the model state file. The function stops if the group in which the table is to be placed does not exist in the datastore and a message is written to the log.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore"
    ]
  },
  
  {
    "Name": "initDataset",
    "Group": "datastore",
    "Description": "Initializes a dataset in a table.",
    "Arguments": 
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the standard module 'Set' specifications described in the model system design documentation."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the group the table is to be created in."
      }
    ],
    "Return": "TRUE if dataset is successfully initialized. If the dataset already exists the function throws an error and writes an error message to the log. Updates the model state file.",
    "Calls":
    [ 
      "getModelState",
      "listDatastore",
      "Types"
    ]
  },
  
  {
    "Name": "writeToTable",
    "Group": "datastore",
    "Description": "Writes data to table and initializes dataset if needed.",
    "Arguments": 
    [
      {
        "Name": "Data_",
        "Description": "A vector of data to be written."
      },
      {
        "Name": "Spec_ls",
        "Description": "A list containing the standard module 'Set' specifications described in the model system design documentation."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the datastore group the data is to be written to."
      },
      {
        "Name": "Index",
        "Description": "A numeric vector identifying the positions the data is to be written to."
      }
    ],
    "Return": "TRUE if data is sucessfully written. Updates model state file.",
    "Calls":
    [ 
      "getModelState",
      "checkDataset",
      "initDataset",
      "writeLog",
      "listDatastore"
    ]
  },
  
  {
    "Name": "readFromTable",
    "Group": "datastore",
    "Description": "Reads a dataset from a table.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the name of the dataset to be read from."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the complete name of the table where the dataset is located."
      },
      {
        "Name": "Group",
        "Description": "A string representation of the name of the datastore group the data is to be read from."
      },
      {
        "Name": "File",
        "Description": "A string representation of the file path of the datastore."
      },
      {
        "Name": "Index",
        "Description": "A numeric vector identifying the positions the data is to be written to. NULL if the entire dataset is to be read."
      }
    ],
    "Return": "A vector of the same type stored in the datastore and specified in the TYPE attribute.",
    "Calls":
    [ 
      "readModelState",
      "checkDataset",
      "writeLog"
    ]
  },
  
  {
    "Name": "createIndex",
    "Group": "control",
    "Description": "Creates an index for reading or writing module data to the datastore.",
    "Arguments": 
    [
      {
        "Name": "Name",
        "Description": "A string identifying the dataset the index is being created for."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the name of the table the index is being created for."
      },
      {
        "Name": "Group",
        "Description": "A string identifying the group the table is located in."
      }
    ],
    "Return": "A function that creates a vector of positions corresponding to the location of the supplied value in the index field.",
    "Calls":
    [ 
      "readFromTable"
    ]
  },
  
  {
    "Name": "initDataList",
    "Group": "control",
    "Description": "Creates a list to be used for transferring data to and from the datastore.",
    "Arguments": 
    [
    ],
    "Return": "A list that has 3 named list components: Global, Year, BaseYear.",
    "Calls":
    [ 
    ]
  },
  
  {
    "Name": "getFromDatastore",
    "Group": "control",
    "Description": "Retrieves datasets identified in a module's 'Get' specifications from the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "Geo",
        "Description": "A string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone."
      },
      {
        "Name": "RunYear",
        "Description": "A string identifying the model year being run. The default is the Year object in the global workspace."
      }
    ],
    "Return": "A list containing all the data sets specified in the module Get specifications for the identified geographic area.",
    "Calls":
    [ 
      "processModuleSpecs",
      "initDataList",
      "getModelState",
      "createIndex",
      "readModelState",
      "checkDataset",
      "readFromTable",
      "deflateCurrency",
      "convertUnits",
      "convertMagnitude"
    ]
  },
  
  {
    "Name": "setInDatastore",
    "Group": "control",
    "Description": "Saves to the datastore the data returned in a standard list by a module.",
    "Arguments": 
    [
      {
        "Name": "Data_ls",
        "Description": "A list containing the data to be saved. The list is organized by group, table, and data set."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document the module creating the data in the datastore)"
      },
      {
        "Name": "Year",
        "Description": "A string identifying the model run year."
      },
      {
        "Name": "Geo",
        "Description": "A string identifying the name of the geographic area to get the data for. For example, if the module is specified to be run by Azone, then Geo would be the name of a particular Azone."
      }
    ],
    "Return": "A logical value which is TRUE if the data are successfully saved to the datastore.",
    "Calls":
    [ 
      "getModelState",
      "checkTableExistence",
      "processModuleSpecs",
      "createIndex",
      "deflateCurrency",
      "convertUnits",
      "convertMagnitude",
      "writeLog",
      "writeToTable"
    ]
  },
  
  {
    "Name": "checkInputYearGeo",
    "Group": "control",
    "Description": "checks the Year and Geo columns of an input file to determine whether they are complete and have no duplications.",
    "Arguments": 
    [
      {
        "Name": "Year_",
        "Description": "The vector extract of the Year column from the input data."
      },
      {
        "Name": "Geo_",
        "Description": "the vector extract of the Geo column from the input data."
      },
      {
        "Name": "Group",
        "Description": "A string identifying the GROUP specification for the data sets contained in the input file."
      },
      {
        "Name": "Table",
        "Description": "A string identifying the TABLE specification for the data sets contained in the input file."
      }
    ],
    "Return": "A list containing the results of the check. The list has two mandatory components and two optional components. CompleteInput is a logical that identifies whether records are present for all years and geographic areas. DupInput identifies where are any redundant year and geography entries. If CompleteInput is FALSE, the list contains a MissingInputs component that is a string identifying the missing year and geography records. If DupInput is TRUE, the list contains a component that is a string identifying the duplicated year and geography records.",
    "Calls":
    [ 
      "getModelState"
    ]
  },
  
  {
    "Name": "findSpec",
    "Group": "control",
    "Description": "Returns the full dataset specification for defined NAME, TABLE, and GROUP.",
    "Arguments": 
    [
      {
        "Name": "Specs_ls",
        "Description": "A standard specifications list for Inp, Get, or Set."
      },
      {
        "Name": "Name",
        "Description": "A string for the name of the dataset."
      },
      {
        "Name": "Table",
        "Description": "A string for the table that the dataset resides in."
      },
      {
        "Name": "Group",
        "Description": "A string for the generic group that the table resides in."
      }
    ],
    "Return": "A list containing the full specifications for the dataset.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "sortGeoTable",
    "Group": "control",
    "Description": "Returns a data frame whose rows are sorted to match the geography in a specified table in the datastore.",
    "Arguments": 
    [
      {
        "Name": "Data_df",
        "Description": "A data frame that contains a 'Geo' field containing the names of the geographic areas to sort by and any number of additional data fields."
      },
      {
        "Name": "Table",
        "Description": "A string for the table that is to be matched against."
      },
      {
        "Name": "Group",
        "Description": "A string for the generic group that the table resides in."
      }
    ],
    "Return": "The data frame which has been sorted to match the order of geography in the specified table in the datastore.",
    "Calls":
    [ 
      "readFromTable"
    ]
  },
  
  {
    "Name": "processModuleInputs",
    "Group": "control",
    "Description": "Processes input files identified in a module Inp specifications in preparation for saving in the datastore.",
    "Arguments": 
    [
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document module in error messages)."
      },
      {
        "Name": "Dir",
        "Description": "A string identifying the relative path to the directory where the model inputs are contained."
      }
    ],
    "Return": "A list containing the results of the input processing. The list has two components. The first (Errors) is a vector of identified file and data errors. The second (Data) is a list containing the data in the input files organized in the standard format for data exchange with the datastore.",
    "Calls":
    [ 
      "getModelState",
      "initDataList",
      "parseInputFieldNames",
      "checkInputYearGeo",
      "checkDataConsistency",
      "deflateCurrency",
      "convertUnits",
      "convertMagnitude",
      "writeLog"
    ]
  },
  
  {
    "Name": "inputsToDatastore",
    "Group": "control",
    "Description": "Takes a list of processed module input files and writes the datasets to the datastore.",
    "Arguments": 
    [
      {
        "Name": "Inputs_ls",
        "Description": "A list processes module inputs as created by the processModuleInputs function."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications that is consistent with the VisionEval requirements."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module (used to document the dataset in the datastore)."
      }
    ],
    "Return": "A logical indicating successful completion. Most of the outputs of the function are the side effects of writing data to the datastore.",
    "Calls":
    [ 
      "processModuleSpecs",
      "initTable",
      "findSpec",
      "sortGeoTable",
      "writeToTable"
    ]
  },
  
  {
    "Name": "binarySearch",
    "Group": "developer",
    "Description": "Uses a binary search algorithm to find the value of a function parameter for which the function achieves a target value.",
    "Arguments": 
    [
      {
        "Name": "Function",
        "Description": "A function which returns a value which is compared to the Target argument. The function must take as its first argument a value which from the SearchRange_. It must return a value that may be compared to the Target value."
      },
      {
        "Name": "SearchRange_",
        "Description": "A two element numeric vector which has the lowest and highest values of the parameter range within which the search will be carried out."
      },
      {
        "Name": "...",
        "Description": "One or more optional arguments for the Function."
      },
      {
        "Name": "Target",
        "Description": "A numeric value that is compared with the return value of the Function."
      },
      {
        "Name": "MaxIter",
        "Description": "An integer specifying the maximum number of iterations to all the search to attempt."
      },
      {
        "Name": "Tolerance",
        "Description": "A numeric value specifying the proportional difference between the 'Target' and the return value of the Function to determine when the search is complete."
      }
    ],
    "Return": "The value in the 'SearchRange_' for the function parameter which matches the target value.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "makeModelFormulaString ",
    "Group": "developer",
    "Description": "Creates a string equivalent of a model equation.",
    "Arguments": 
    [
      {
        "Name": "EstimatedModel",
        "Description": "The return value of the lm or glm functions."
      }
    ],
    "Return": "A string expression of the model equation.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "applyBinomialModel",
    "Group": "developer",
    "Description": "Applies an estimated binomial model to a set of input data.",
    "Arguments": 
    [
      {
        "Name": "Model_ls",
        "Description": "a list which contains the following components: 1) Type - which has a value of binomial; 2) Formula - a string representation of the model equation; 3) Choices - a two-element vector listing the choice set. The first element is the choice that the binary logit model equation predicts the odds of; 4) PrepFun - a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 5) SearchRange - a two-element numeric vector which specifies the acceptable search range to use when determining the factor for adjusting the model constant."
      },
      {
        "Name": "Data_df",
        "Description": "A data frame containing the data required for applying the model."
      },
      {
        "Name": "TargetProp",
        "Description": "A number identifying a target proportion for the default choice to be achieved for the input data or NULL if there is no target proportion to be achieved."
      },
      {
        "Name": "CheckTargetSearchRange",
        "Description": "A logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range."
      }
    ],
    "Return": "A vector of choice values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a two-element vector identifying if the search range produces NA or NaN values.",
    "Calls":
    [
      "binarySearch"
    ]
  },
  
  {
    "Name": "applyLinearModel",
    "Group": "developer",
    "Description": "Applies an estimated linear model to a set of input data.",
    "Arguments": 
    [
      {
        "Name": "Model_ls",
        "Description": "A list which contains the following components: 1) Type which has a value of 'linear'; 2) Formula a string representation of the model equation; 3) PrepFun a function which prepares the input data frame for the model application. If no preparation, this element of the list should not be present or should be set equal to NULL; 4) SearchRange a two-element numeric vector which specifies the acceptable search range to use when determining the dispersion factor. 5) OutFun a function that is applied to transform the results of applying the linear model. For example to untransform a power-transformed variable. If no transformation is necessary, this element of the list should not be present or should be set equal to NULL."
      },
      {
        "Name": "Data_df",
        "Description": "A data frame containing the data required for applying the model."
      },
      {
        "Name": "TargetMean",
        "Description": "A number identifying a target mean value to be achieved  or NULL if there is no target."
      },
      {
        "Name": "CheckTargetSearchRange",
        "Description": "a logical identifying whether the function is to only check whether the specified 'SearchRange' for the model will produce acceptable values (i.e. no NA or NaN values). If FALSE (the default), the function will run the model and will not check the target search range."
      }
    ],
    "Return": "A vector of numeric values for each record of the input data frame if the model is being run, or if the function is run to only check the target search range, a summary of predicted values when the model is run with dispersion set at the high value of the search range.",
    "Calls":
    [ 
      "binarySearch"
    ]
  },
  
  {
    "Name": "item",
    "Group": "developer",
    "Description": "Is an alias for the list function whose purpose is to make module specifications easier to read.",
    "Arguments": 
    [
    ],
    "Return": "A list.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "items",
    "Group": "developer",
    "Description": "Is an alias for the list function whose purpose is to make module specifications easier to read.",
    "Arguments": 
    [
    ],
    "Return": "A list.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "processEstimationInputs",
    "Group": "developer",
    "Description": "Checks whether specified model estimation data meets specifications and returns the data in a data frame.",
    "Arguments": 
    [
      {
        "Name": "Inp_ls",
        "Description": "A list that describes the specifications for the estimation file. This list must meet the framework standards for specification description."
      },
      {
        "Name": "FileName",
        "Description": "A string identifying the file name. This is the file name without any path information. The file must located in the inst/extdata directory of the package."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module the estimation data is being used in."
      }
    ],
    "Return": "A data frame containing the estimation data.",
    "Calls":
    [ 
      "checkDataConsistency"
    ]
  },
  
  {
    "Name": "checkModuleOutputs",
    "Group": "control",
    "Description": "Checks output list produced by a module for consistency with the module's specifications.",
    "Arguments":
    [
      {
        "Name": "Data_ls",
        "Description": "A list of all the datasets returned by a module in the standard list form required by the VisionEval model system."
      },
      {
        "Name": "ModuleSpec_ls",
        "Description": "A list of module specifications in the standard list form required by the VisionEval model system."
      },
      {
        "Name": "ModuleName",
        "Description": "A string identifying the name of the module."
      }
    ],
    "Return": "A character vector containing a list of error messages or having a length of 0 if there are no error messages.",
    "Calls":
    [
      "processModuleSpecs",
      "checkDataConsistency"
    ]
  },
  
  {
    "Name": "testModule",
    "Group": "developer",
    "Description": "Sets up a test environment and tests a module.",
    "Arguments":
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the module name."
      },
      {
        "Name": "ParamDir",
        "Description": "A string identifying the location of the directory where the run parameters, model parameters, and geography definition files are located. The default value is defs. This directory should be located in the tests directory."
      },
      {
        "Name": "RunParamFile",
        "Description": "A string identifying the name of the run parameters file. The default value is run_parameters.json."
      },
      {
        "Name": "GeoFile",
        "Description": "A string identifying the name of the file which contains geography definitions."
      },
      {
        "Name": "ModelParamFile",
        "Description": "A string identifying the name of the file which contains model parameters. The default value is model_parameters.json."
      },
      {
        "Name": "LoadDatastore",
        "Description": "A logical value identifying whether to load an existing datastore. If TRUE, it loads the datastore whose name is identified in the run_parameters.json file. If FALSE it initializes a new datastore."
      },
      {
        "Name": "SaveDatastore",
        "Description": "A logical value identifying whether the module outputs will be written to the datastore. If TRUE the module outputs are written to the datastore. If FALSE the outputs are not written to the datastore."
      },
      {
        "Name": "DoRun",
        "Description": "A logical value identifying whether the module should be run. If FALSE, the function will initialize a datastore, check specifications, and load inputs but will not run the module but will return the list of module specifications. That setting is useful for module development in order to create the all the data needed to assist with module programming. It is used in conjunction with the getFromDatastore function to create the dataset that will be provided by the framework. The default value for this parameter is TRUE. In that case, the module will be run and the results will checked for consistency with the Set specifications."
      }
    ],
    "Return": "None. The function writes out messages to the console and to the log as the testing proceeds. These messages include the time when each test starts and when it ends. When a key test fails, requiring a fix before other tests can be run, execution stops and an error message is written to the console. Detailed error messages are also written to the log.",
    "Calls":
    [
      "initModelStateFile",
      "initLog",
      "writeLog",
      "getModelState",
      "loadDatastore",
      "initDatastore",
      "readGeography",
      "initDatastoreGeography",
      "loadModelParameters",
      "processModuleSpecs",
      "checkModuleSpecs",
      "processModuleInputs",
      "inputsToDatastore",
      "checkDataset",
      "getYears",
      "getFromDatastore",
      "checkModuleOutputs",
      "readFromTable",
      "setInDatastore"
    ]
  },
  
  {
    "Name": "parseUnitsSpec",
    "Group": "control",
    "Description": "Parses the UNITS attribute of a standard Inp, Get, or Set specification for a dataset to identify the units name, multiplier, and year for currency data. Returns a modified specifications list whose UNITS value is only the units name, and includes a MULTIPLIER attribute and YEAR attribute.",
    "Arguments":
    [
      {
        "Name": "Spec_ls",
        "Description": "A standard specifications list for a Inp, Get, or Set item."
      }
    ],
    "Return": "A list that is a standard specifications list with the addition of a MULTIPLIER component and a YEAR component as well as a modification of the UNIT component. The MULTIPLIER component can have the value of NA, a number, or NaN. The value is NA if the multiplier is missing. It is a number if the multiplier is a valid number. The value is NaN if the multiplier is not a valid number. The YEAR component is a character string that is a 4-digit representation of a year or NA if the component is missing or not a proper year. The UNITS component is modified to only be the units name.",
    "Calls": 
    [
    ]
  },
  
  {
    "Name": "expandSpec",
    "Group": "control",
    "Description": "Takes a Inp, Get, or Set specification and processes it to be in a form that can be used by other functions which use the specification in processing inputs or reading from or writing to the datastore. The parseUnitsSpec function is called to parse the UNITS attribute to extract name, multiplier, and year values. When the specification has multiple values for the NAME attribute, the function creates a specification for each name value.",
    "Arguments":
    [
      {
        "Name": "SpecToExpand_ls",
        "Description": "A standard specifications list for a specification whose NAME attribute has multiple values."
      }
    ],
    "Return": "A list of standard specifications lists which has a component for each value in the NAME attribute of the input specifications list.",
    "Calls":
    [
      "parseUnitsSpec"
    ]
  },
  
  {
    "Name": "checkSpecTypeUnits",
    "Group": "control",
    "Description": "Checks correctness of TYPE, UNITS, MULTIPLIER and YEAR attributes of expanded specification. This function is called by the checkModuleSpecs function.",
    "Arguments":
    [
      {
        "Name": "Spec_ls",
        "Description": "A list for a single specification (e.g. a Get specification for a dataset) that has been processed with the parseUnitsSpec function to split the name, multiplier, and year elements of the UNITS specification."
      },
      {
        "Name": "SpecGroup",
        "Description": "A string identifying the group that this specification comes from (e.g. Inp, Get, Set)."
      },
      {
        "Name": "SpecNum",
        "Description": "A number identifying which specification in the order of the SpecGroup. This is used to identify the subject specification if an error is identified."
      }
      
    ],
    "Return": "A vector containing messages identifying any errors that are found.",
    "Calls":
    [
      "Types",
      "checkUnits"
    ]
  },
  
  {
    "Name": "checkSpec",
    "Group": "control",
    "Description": "Function checks a single module specification for completeness and for proper values.",
    "Arguments":
    [
      {
        "Name": "Spec_ls",
        "Description": "A list containing the specifications for a single item in a module specifications list."
      },
      {
        "Name": "SpecGroup",
        "Description": "A string identifying the specifications group the specification is in (e.g. RunBy, NewInpTable, NewSetTable, Inp, Get, Set). This is used in the error messages to identify which specification has errors."
      },
      {
        "Name": "SpecNum",
        "Description": "An integer identifying which specification in the specifications group has errors."
      }
    ],
    "Return": "A vector containing messages identifying any errors that are found.",
    "Calls":
    [
      "parseUnitsSpec",
      "checkSpecTypeUnits",
      "SpecRequirements"
    ]
  },
  
  {
    "Name": "Types",
    "Group": "control",
    "Description": "Returns a list of returns a list of recognized data types, the units for each type, and storage mode of each type.",
    "Arguments":
    [
    ],
    "Return": "A list containing a component for each recognized type. Each component lists the recognized units for the type and the storage mode. There are currently 4 simple types and 10 complex type. The simple types are integer, double, character and logical. The complex types are currency, distance, area, mass, volume, time, speed, vehicle_distance, passenger_distance, and payload_distance.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "SpecRequirements",
    "Group": "control",
    "Description": "Returns a list of basic requirements for module specifications to be used for checking correctness of specifications.",
    "Arguments":
    [
    ],
    "Return": "A list comprised of six named components: RunBy, NewInpTable, NewSetTable, Inp, Get, Set. Each main component is a list that has a component for each specification item that has values to be checked. For each such item there is a list having two components: ValueType and ValuesAllowed. The ValueType component identifies the data type that the data entry for the item must have (e.g. character, integer). The ValuesAllowed item identifies what values the item may have.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "parseInputFieldNames",
    "Group": "control",
    "Description": "parses the field names of an input file to separate out the field name, currency year (if data is currency type), and value multiplier.",
    "Arguments":
    [
      {
        "Name": "FieldNames_",
        "Description": "A character vector containing the field names of an input file."
      },
      {
        "Name": "Specs_ls",
        "Description": "A list of specifications for fields in the input file."
      },
      {
        "Name": "FileName",
        "Description": "A string identifying the name of the file that the field names are from. This is used for writing error messages."
      }
    ],
    "Return": "A named list with one component for each field. Each component is a list having 4 named components: Error, Name, Year, Multiplier. The Error component has a value of character(0) if there are no errors or a character vector of error messages if there are errors. The Name component is a string with the name of the field. The Year component is a string with the year component if the data type is currency or NA if the data type is not currency or if the Year component has an invalid value. The Multiplier is a number if the multiplier component is present and is valid. It is NA if there is no multiplier component and NaN if the multiplier is invalid.  Each component of  the list is named with the value of the Name component (i.e. the field name without the year and multiplier elements.)",
    "Calls":
    [
      "getModelState"
    ]       
  },
  
  {
    "Name": "convertUnits",
    "Group": "control",
    "Description": "Converts values between different units of measure for complex and compound data types recognized by the visioneval code.",
    "Arguments":
    [
      {
        "Name": "Values_",
        "Description": "A numeric vector of values to convert from one unit to another."
      },
      {
        "Name": "DataType",
        "Description": "A string identifying the data type."
      },
      {
        "Name": "FromUnits",
        "Description": "A string identifying the units of measure of the Values_."
      },
      {
        "Name": "ToUnits",
        "Description": "A string identifying the units of measure to convert the Values_ to."
      }
    ],
    "Return": "A list containing the converted values and additional information as follows: Values - a numeric vector containing the converted values; FromUnits - a string representation of the units converted from; ToUnits - a string representation of the units converted to. Errors - a string containing an error message or character(0) if no errors; Warnings - a string containing a warning message or character(0) if no warning.",
    "Calls":
    [
      "Types",
      "checkUnits",
      "getUnits"
    ]
  },
  
  {
    "Name": "convertMagnitude",
    "Group": "control",
    "Description": "Converts values between different magnitudes such as between dollars and thousands of dollars.",
    "Arguments":
    [
      {
        "Name": "Values_",
        "Description": "A numeric vector of values to convert from one unit to another."
      },
      {
        "Name": "FromMagnitude",
        "Description": "A number or string identifying the magnitude of the units of the input Values_."
      },
      {
        "Name": "ToMagnitude",
        "Description": "A number or string identifying the magnitude to convert the Values_ to."
      }
    ],
    "Return": "A numeric vector of values corresponding the the input Values_ but converted from the magnitude identified in the FromMagnitude argument to the magnitude identified in the ToMagnitude argument. If either the FromMagnitude or the ToMagnitude arguments is NA, the original Values_ are returned. The Converted attribute of the returned values is FALSE. Otherwise the conversion is done and the Converted attribute of the returned values is TRUE.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "deflateCurrency",
    "Group": "control",
    "Description": "Converts currency values between different years of measure.",
    "Arguments": 
    [
      {
        "Name": "Values_",
        "Description": "A numeric vector of values to convert from one currency year to another."
      },
      {
        "Name": "FromYear",
        "Description": "A number or string identifying the currency year of the input  Values_."
      },
      {
        "Name": "ToYear",
        "Description": "A number or string identifying the currency year to convert the Values_ to."
      }
    ],
    "Return": "A numeric vector of values corresponding the the input Values_ but converted from the currency year identified in the FromYear argument to the currency year identified in the ToYear argument. If either the FromYear or the ToYear arguments is unaccounted for in the deflator series, the original Values_ are returned with a Converted attribute of FALSE. Otherwise the conversion is done and the Converted attribute of the returned values is TRUE.",
    "Calls":
    [
      "getModelState"
    ]
  },
  
  {
    "Name": "checkUnits",
    "Group": "control",
    "Description": "Check measurement units for consistency with recognized units for stated type.",
    "Arguments":
    [
      {
        "Name": "DataType",
        "Description": "A string which identifies the data type as specified in the TYPE attribute for a data set."
      },
      {
        "Name": "Units",
        "Description": "A string identifying the measurement units as specified in the UNITS attribute for a data set after processing with the parseUnitsSpec function."
      }
    ],
    "Return": "A list which contains the following elements: DataType - a string identifying the data type; UnitType - a string identifying whether the units correspond to a 'simple' data type, a 'complex' data type, or a 'compound' data type; Units - a string identifying the units; Errors - a string containing an error message or character(0) if no error; and Elements - a list containing the elements of a compound units. Components of this list are: Types - the complex type of each element, Units - the units of each element; and Operators - the operators that separate the units.",
    "Calls":
    [
      "Types"
    ]
  },
  
  {
    "Name": "readVENameRegistry",
    "Group": "developer",
    "Description": "Reads the VisionEval name registry and returns a list of data frames containing the Inp and Set specifications.",
    "Arguments":
    [
      {
        "Name": "NameRegistryDir",
        "Description": "A string identifying the path to the directory where the name registry file is located."
      }
    ],
    "Return": "A list having two components: Inp and Set. Each component is a data frame containing the respective Inp and Set specifications of registered modules.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "getRegisteredGetSpecs",
    "Group": "developer",
    "Description": "Returns a data frame of Get specifications for datasets in the VisionEval name registry.",
    "Arguments":
    [
      {
        "Name": "Names_",
        "Description": "A character vector of the dataset names to get specifications for."
      },
      {
        "Name": "Tables_",
        "Description": "A character vector of the tables that the datasets are a part of."
      },
      {
        "Name": "Groups_",
        "Description": "A character vector of the groups that the tables are a part of."
      },
      {
        "Name": "NameRegistryDir",
        "Description": "A string identifying the path to the directory where the name registry file is located."
      }
    ],
    "Return": "A data frame containing the Get specifications for the identified datasets.",
    "Calls":
    [
    ]
  },
  
  {
    "Name": "writeVENameRegistry",
    "Group": "control",
    "Description": "Writes module Inp and Set specifications to the VisionEval name registry.",
    "Arguments":
    [
      {
        "Name": "ModuleName",
        "Description": "A string identifying the module name."
      },
      {
        "Name": "PackageName",
        "Description": "A string identifying the package name."
      },
      {
        "Name": "NameRegistryDir",
        "Description": "A string identifying the path to the directory where the name registry file is located."
      }
    ],
    "Return": "TRUE if successful. Has a side effect of updating the VisionEval name registry.",
    "Calls":
    [
      "readVENameRegistry",
      "processModuleSpecs"
    ]
  }
  
]
